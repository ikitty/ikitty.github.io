<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="renderer" content="webkit" />
<meta name="viewport" content="initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="robots" content="all" />
<title> TreeMenu by Recursive </title>
</head>
<body>

<h2> TreeMenu by Recursive </h2>
<div id="ret">
    
</div>

<script>
var V = function () {
    this.init.apply(this, arguments)
};
V.prototype = {
    init: function (arg) {
        this.cfg = {}
        for (var i in arg) { this.cfg[i]= arg[i] }
        var self = this
        window.say = ()=>{
            console.log(this.cfg.name) ;
        }
        //两个实例都会返回beta，因为第二个全局函数被覆盖了
        setTimeout(function () {
            say()
        }, 1000);
    }
}
var v1 = new V({name: 'alpha'})
var v2 = new V({name: 'beta'})

var LazyMan = function () {
    this.init.apply(this, arguments)
};
LazyMan.prototype = {
    init: function (name) {

        var self = this
        var fn = function () {
            console.log(name) ;
            self.task.next()
        }
        this.task.push(fn)
        setTimeout(function () {
            self.task.next()
        }, 0);
    },
    task: (function () {
        var q = []
        function push (fn) {
            q.push(fn)
        }
        function next () {
            var fn = q.shift()
            fn && fn()
        }
        return {push,  next} ;
    })(),
    eat: function (food) {
        var self = this
        this.task.push(function () {
            console.log(`Eat ${food}`) ;
            self.task.next()
        })
        return this ;
    },
    sleep: function (t) {
        var self = this
        this.task.push(async function () {

            console.log('sleep') ;
            await sleep(t)
            console.log('wake', t) ;
            self.task.next()
        })
        return this ;
    }
}
function L (name) {
    return new LazyMan(name) ;
}
L('boby').sleep(2000).eat('b')
// L('boby').sleep(2000).eat('Food')

function sleep (time) {
    return new Promise(function (resolve, reject) {
        if (time<500) {
            setTimeout(function () {
                reject('not enough')
            }, 500);
        }else {
            setTimeout(resolve, time);
        }
    })
}
async function A (argument) {
    try {
        var ret = await Promise.all([sleep(50), sleep(600)])
        console.log('await OK') ;
        // await sleep(1000)
        // await sleep(50)
    }catch (e){
        console.log('err', e) ;
    }
}
A()
</script>

</body>
</html>
