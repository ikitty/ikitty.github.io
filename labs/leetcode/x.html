<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="renderer" content="webkit" />
<meta name="viewport" content="initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="robots" content="all" />
<title> TreeMenu by Recursive </title>
</head>
<body>

<h2> TreeMenu by Recursive </h2>
<div id="ret">
    
</div>

<script>
var V = function () {
    this.init.apply(this, arguments)
};
V.prototype = {
    init: function (arg) {
        this.cfg = {}
        for (var i in arg) { this.cfg[i]= arg[i] }
        var self = this
        window.say = ()=>{
            console.log(this.cfg.name) ;
        }
        //两个实例都会返回beta，因为第二个全局函数被覆盖了
        setTimeout(function () {
            say()
        }, 1000);
    }
}
// var v1 = new V({name: 'alpha'})
// var v2 = new V({name: 'beta'})

var LazyMan = function () {
    this.init.apply(this, arguments)
};
LazyMan.prototype = {
    init: function (name) {

        var self = this
        var fn = function () {
            console.log(name) ;
            self.task.next()
        }
        this.task.push(fn)
        setTimeout(function () {
            self.task.next()
        }, 0);
    },
    task: (function () {
        var q = []
        function push (fn) {
            q.push(fn)
        }
        function next () {
            var fn = q.shift()
            fn && fn()
        }
        return {push,  next} ;
    })(),
    eat: function (food) {
        var self = this
        this.task.push(function () {
            console.log(`Eat ${food}`) ;
            self.task.next()
        })
        return this ;
    },
    sleep: function (t) {
        var self = this
        this.task.push(async function () {

            console.log('sleep') ;
            await sleep(t)
            console.log('wake', t) ;
            self.task.next()
        })
        return this ;
    }
}
function L (name) {
    return new LazyMan(name) ;
}
// L('boby').sleep(2000).eat('b')

function sleep (time) {
    return new Promise(function (resolve, reject) {
        if (time<500) {
            setTimeout(function () {
                reject('not enough')
            }, 500);
        }else {
            setTimeout(resolve, time);
        }
    })
}
async function A (argument) {
    try {
        var ret = await Promise.all([sleep(50), sleep(600)])
        console.log('await OK') ;
        // await sleep(1000)
        // await sleep(50)
    }catch (e){
        console.log('err', e) ;
    }
}
// A()

(function fnTest (argument) {
    var a = 1;
    a=2
    a=3

    a++

    console.log(a) ;
})();

var count = 0
function divideSearch (arr, key , start, end) {
    if (count++>5) { return -999 ; }

    start = start || 0
    end = end || (arr.length - 1)
    //上面这个写法有误，下面的才是正确的
    // if (undefined === end) { end = arr.length -1 }
    //bp跟踪变量的正确用法
    //F8断点暂停和继续 此时，看到的变量都是到断点位置时计算出来的，所以第一次以为是数据错误了
    //要正确追踪变量，应该用单步进入F11
    var mid = Math.floor((start + end) /2)
    var mid_v = arr[mid]
    if (key === mid_v) {
        return mid ;
    }
    if (start == end) {
        console.log('not found') ;
        return -1 ;
    }
    if (key > mid_v ) {
        start = mid + 1
        return divideSearch(arr,key , start , end) ;
    }else {
        end = mid - 1
        return divideSearch(arr,key , start , end) ;
    }
}
var testArr = [-11, 11, 22,33,44,55,77,99]
console.log(divideSearch(testArr, 1)) ;


//quickSort
function quickSort (arr) {
    if (arr.length <= 1) {
        return arr ;
    }
    var mid = Math.floor((arr.length-1)/2)
    var mid_v = arr.splice(mid, 1)[0]
    var left = [] , right = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] < mid_v) {
            left.push(arr[i])
        }else {
            right.push(arr[i])
        }
    };
    return quickSort(left).concat(mid_v, quickSort(right)) ;
}
console.log(quickSort([3,1,5,0,-1,9,2])) ;
</script>

</body>
</html>
